(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{444:function(t,e,a){"use strict";a.r(e);var l=a(9),r=Object(l.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("浏览器中负责页面呈现的模块是 渲染引擎，我们比较熟悉的有 Webkit,Gecko 等。\n概述整个过程：")]),t._v(" "),a("ul",[a("li",[t._v("解析HTML，生成 DOM tree")]),t._v(" "),a("li",[t._v("解析各种样式并结合DOM tree 生成 render tree")]),t._v(" "),a("li",[t._v("对  render tree 各个节点计算布局信息，比如说 box 的位置与尺寸，宽高")]),t._v(" "),a("li",[t._v("根据render tree 并利用浏览器 UI 层进行绘制")])]),t._v(" "),a("p",[t._v("注意： DOM tree 和 render tree 不是 一一对应的关系，比如 display:none 的节点， 只存在 DOM tree 上，不存在  render tree 上，因为不会渲染。")]),t._v(" "),a("p",[t._v("这是 webkit 基本流程。\n"),a("img",{attrs:{src:"https://box.kancloud.cn/2016-05-06_572c45a93efc0.jpg",alt:"webkit 基本流程"}})]),t._v(" "),a("p",[t._v("Paint是一个耗时的过程，然而layout是一个更耗时的过程，我们无法确定layout一定是自上而下或是自下而上进行的，甚至一次layout会牵涉到整个文档布局的重新计算。")]),t._v(" "),a("p",[t._v("但是layout是肯定无法避免的，所以我们主要是要最小化layout的次数。")]),t._v(" "),a("p",[t._v("在考虑如何最小化layout次数之前，要先了解什么时候浏览器会进行layout。\nLayout（reflow）一般被称为布局，这个操作是用来计算文档中元素的位置和大小，是渲染前重要的一步。在HTML第一次被加载的时候，会有一次layout之外，js脚本的执行和样式的改变同样会导致浏览器执行layout，这也是本文的主要要讨论的内容。")]),t._v(" "),a("p",[t._v("一般情况下，浏览器的layout是lazy的，也就是说：在js脚本执行时，是不会去更新DOM的，任何对DOM的修改都会被暂存在一个队列中，在当前js的执行上下文完成执行后，会根据这个队列中的修改，进行一次layout。\n然而有时希望在js代码中立刻获取最新的DOM节点信息，浏览器就不得不提前执行layout，这是导致DOM性能问题的主因。")]),t._v(" "),a("h3",{attrs:{id:"什么情况下浏览器会进行layout-？"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么情况下浏览器会进行layout-？"}},[t._v("#")]),t._v(" 什么情况下浏览器会进行layout ？")]),t._v(" "),a("ul",[a("li",[t._v("通过js获取需要计算的DOM属性")]),t._v(" "),a("li",[t._v("添加或删除DOM元素")]),t._v(" "),a("li",[t._v("resize浏览器窗口大小")]),t._v(" "),a("li",[t._v("改变字体")]),t._v(" "),a("li",[t._v("css伪类的激活，比如:hover")]),t._v(" "),a("li",[t._v("通过js修改DOM元素样式且该样式涉及到尺寸的改变")])]),t._v(" "),a("h3",{attrs:{id:"最小化layout的方案"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#最小化layout的方案"}},[t._v("#")]),t._v(" 最小化layout的方案")]),t._v(" "),a("ul",[a("li",[t._v("批量读写")]),t._v(" "),a("li",[t._v("先对一个不在Render tree上的节点进行一系列操作，再把这个节点添加回Render tree，这样无论多么复杂的DOM操作，最终都只会触发一次layout")]),t._v(" "),a("li",[t._v("动画的每一帧都会导致layout，这是无法避免的。但是为了减少动画带来的layout的性能损失，可以将动画元素绝对定位，这样动画元素脱离文本流，layout的计算量会减少很多。")]),t._v(" "),a("li",[t._v("使用requestAnimationFrame: 在现实项目中，代码按模块划分，很难像上例那样组织批量读写。那么这时可以把写操作放在requestAnimationFrame的callback中，统一让写操作在下一次paint之前执行")])])])}),[],!1,null,null,null);e.default=r.exports}}]);